{"version":3,"sources":["images lazy /^/.//.*$/ groupOptions: {} namespace object","Gallery.js","Image.js","utils/getOrCreateAuthToken.js","Image2.js","utils/utils.js","utils/api.js","TempGen.js","App.js","serviceWorker.js","index.js"],"names":["map","webpackAsyncContext","req","__webpack_require__","o","Promise","resolve","then","e","Error","code","ids","id","t","keys","Object","module","exports","logo","Image","props","setSpans","height","imageRef","current","clientHeight","spans","Math","ceil","setState","state","React","createRef","this","addEventListener","style","gridRowEnd","ref","src","image","url","alt","name","onClick","handleclick","Component","process","env","REACT_APP_LOGO","default","cachedToken","Gallery","className","position","top","right","width","handleRandom","images","key","image_source","uuid","v1","namespace","data","window","localStorage","setItem","JSON","stringify","store","getItem","parse","fetch","require","ENDPOINT","REACT_APP_ASTRA_DB_ID","REACT_APP_ASTRA_DB_REGION","REACT_APP_ASTRA_DB_USERNAME","REACT_APP_ASTRA_DB_PASSWORD","getOrCreateAuthToken","a","method","headers","body","username","password","response","json","getMemesSaved","query","REACT_APP_ASTRA_DB_KEYSPACE","TABLE_NAME","authToken","saveMemes","meme","sessionId","utils","columns","value","initialState","toptext","bottomtext","isTopDragging","isBottomDragging","topX","topY","bottomX","bottomY","saved_images","TempGen","getStateObj","type","rect","getBoundingClientRect","xOffset","clientX","left","yOffset","clientY","stateObj","changeText","event","currentTarget","resizeText","handleMouseDown","document","handleMouseMove","handleMouseUp","removeEventListener","saveMeme","getElementById","length","svg","getSessionId","resetBoxes","fontSize","currentWidth","textLength","baseVal","imageWidth","params","URLSearchParams","location","search","get","sid","imageId","rows","newHeight","textStyle","fontFamily","textTransform","fill","stroke","userSelect","toggleSelected","el","svgRef","xlinkHref","zIndex","x","y","dominantBaseline","textAnchor","onMouseDown","onMouseUp","placeholder","onChange","App","memes","selected","selectedImg","handleImgClick","find","i","target","chooseRandom","floor","random","toggleComponent","r","console","log","filter","box_count","Boolean","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.789a8f99.chunk.js","sourcesContent":["var map = {\n\t\"./aws.png\": [\n\t\t217,\n\t\t3\n\t],\n\t\"./azure.png\": [\n\t\t218,\n\t\t4\n\t],\n\t\"./canada.png\": [\n\t\t219,\n\t\t5\n\t],\n\t\"./gcp.png\": [\n\t\t220,\n\t\t6\n\t],\n\t\"./usa.jpg\": [\n\t\t221,\n\t\t7\n\t]\n};\nfunction webpackAsyncContext(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\treturn Promise.resolve().then(function() {\n\t\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t});\n\t}\n\n\tvar ids = map[req], id = ids[0];\n\treturn __webpack_require__.e(ids[1]).then(function() {\n\t\treturn __webpack_require__.t(id, 7);\n\t});\n}\nwebpackAsyncContext.keys = function webpackAsyncContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackAsyncContext.id = 114;\nmodule.exports = webpackAsyncContext;","import React, { Component } from \"react\";\nimport Image from \"./Image\";\nimport \"./ImageList.css\"\n\n  let logo;\n    import(`./images/${process.env.REACT_APP_LOGO}`).then((module) => {\n      logo = module.default;\n  });\n\nexport default class Gallery extends Component {\n  render() {\n    return (\n      <div>\n        <div className=\"h1\">\n          MEME GENERATOR \n           </div>\n           <img className=\"icon\" src={logo} alt=\"Logo\" style={{position: 'absolute', top: 10, right: 15, width: '7%', height: 100}}/>\n\n       \n\n        <div>\n          <button className=\"btn-gallery\" onClick={() => this.props.handleRandom()}>Gimme a Random Meme</button>\n          \n        \n        </div>\n\n        <div className=\"image-list\">\n          {this.props.images.map((image) => {\n            return (\n              <Image\n                key={image.id}\n                image={image}\n                handleclick={this.props.handleclick}\n              />\n            );\n          })}\n        </div>\n      </div>\n    );\n  }\n}\n","import React from \"react\";\nexport default class Image extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      spans: 0,\n    }\n    this.imageRef = React.createRef();\n  }\n\n  componentDidMount() {\n    this.imageRef.current.addEventListener('load', this.setSpans)\n  }\n\n  setSpans = () => {\n    const height = this.imageRef.current.clientHeight;\n    const spans = Math.ceil(height / 10 + 2)\n    this.setState({ spans })\n  }\n\n  render() {\n    return (\n      <div style={{ gridRowEnd: `span ${this.state.spans}` }}>\n        <img\n          ref={this.imageRef}\n          src={this.props.image.url}\n          alt={this.props.image.name}\n          id={this.props.image.id}\n          onClick={(e) => this.props.handleclick(e)}\n        />\n      </div>\n    );\n  }\n}\n","const fetch = require('cross-fetch')\nconst ENDPOINT = `https://${process.env.REACT_APP_ASTRA_DB_ID}-${process.env.REACT_APP_ASTRA_DB_REGION}.apps.astra.datastax.com/api/rest/v1`;\nconst REACT_APP_ASTRA_DB_USERNAME = process.env.REACT_APP_ASTRA_DB_USERNAME;\nconst REACT_APP_ASTRA_DB_PASSWORD = process.env.REACT_APP_ASTRA_DB_PASSWORD;\n\n/*\n * This global variable will persist across requests throughout the life of the lambda.\n * We only need to fetch a token for the first request\n * Lambda creates new containers when the original one expires or if there is high concurrency\n * in which case the new containers will have to fetch their own tokens.\n */\nlet cachedToken;\n\nexport default async function getOrCreateAuthToken() {\n  if (cachedToken) {\n    return cachedToken;\n  }\n  try {\n    //console.log(ENDPOINT)\n    const response = await fetch(`${ENDPOINT}/auth`, {\n      method: 'POST',\n      headers: {\n        'content-type': 'application/json',\n      },\n      body: JSON.stringify({\n        username: REACT_APP_ASTRA_DB_USERNAME,\n        password: REACT_APP_ASTRA_DB_PASSWORD,\n      }),\n    });\n    cachedToken = await response.json();\n    return cachedToken;\n  } catch (e) {\n    throw new Error('Could not authenticate with the Astra API');\n  }\n}","import React from \"react\";\nexport default class Image extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      spans: 0,\n    }\n    this.imageRef = React.createRef();\n  }\n\n  componentDidMount() {\n    this.imageRef.current.addEventListener('load', this.setSpans)\n  }\n\n  setSpans = () => {\n    const height = this.imageRef.current.clientHeight;\n    const spans = Math.ceil(height / 10 + 2)\n    this.setState({ spans })\n  }\n\n  render() {\n    return (\n      <div style={{ gridRowEnd: `span ${this.state.spans}` }}>\n        <img\n          ref={this.imageRef}\n          src={this.props.image.image_source}\n          alt={this.props.image.name}\n          id={this.props.image.id}\n          //onClick={(e) => this.props.handleclick(e)}\n        />\n      </div>\n    );\n  }\n}\n","/* global localStorage */\n\nimport uuid from 'node-uuid'\n\nexport default {\n  uuid() {\n    return uuid.v1()\n  },\n  pluralize(count, word) {\n    return count === 1 ? word : `${word}s`;\n  },\n  store(namespace, data) {\n    if (typeof window !== 'undefined') {\n      if (data) {\n        return localStorage.setItem(namespace, JSON.stringify(data));\n      }\n      const store = localStorage.getItem(namespace);\n      return (store && JSON.parse(store)) || null;\n    }\n    return null;\n  },\n};\n","import utils from './utils';\nimport getOrCreateAuthToken from './getOrCreateAuthToken';\n\nexport const getMemes = async (sessionId) => {\n\n  const fetch = require('cross-fetch');\n  const ENDPOINT = `https://${process.env.REACT_APP_ASTRA_DB_ID}-${process.env.REACT_APP_ASTRA_DB_REGION}.apps.astra.datastax.com/api/rest/v1`;\n  const REACT_APP_ASTRA_DB_KEYSPACE = process.env.REACT_APP_ASTRA_DB_KEYSPACE;\n  const TABLE_NAME = 'memegen';\n  const {authToken} = await getOrCreateAuthToken();\n\n  try {\n    const response = await fetch(`${ENDPOINT}/keyspaces/${REACT_APP_ASTRA_DB_KEYSPACE}/tables/${TABLE_NAME}/rows`, {\n      headers: {\n        'x-cassandra-token': authToken\n      }\n    });\n    return response.json();\n  } catch (e) {\n    return JSON.stringify(e);\n  }\n};\n\nexport const getMemesSaved = async (query) => {\n  const fetch = require('cross-fetch');\n  const ENDPOINT = `https://${process.env.REACT_APP_ASTRA_DB_ID}-${process.env.REACT_APP_ASTRA_DB_REGION}.apps.astra.datastax.com/api/rest/v1`;\n  const REACT_APP_ASTRA_DB_KEYSPACE = process.env.REACT_APP_ASTRA_DB_KEYSPACE;\n  const TABLE_NAME = 'memes_saved';\n  const {authToken} = await getOrCreateAuthToken();\n\n  try {\n    const response = await fetch(`${ENDPOINT}/keyspaces/${REACT_APP_ASTRA_DB_KEYSPACE}/tables/${TABLE_NAME}/rows/query`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'x-cassandra-token': authToken\n      },\n      body: query\n    });\n    return response.json();\n  } catch (e) {\n    return JSON.stringify(e);\n  }\n};\n\nexport const deleteMemes = async (sessionId) => {\n  // stub for code in /functions\n  //return response.json();\n};\n\nexport const saveMemes = async (meme, sessionId) => {\n  //if (!meme.uuid) {\n  //  meme.uuid = utils.uuid();\n  //}\n  meme.uuid = utils.uuid();\n  meme['sessionid'] = sessionId;\n\n  const columns = {\n    columns: Object.keys(meme).map(key => {\n      return {\n        name: key,\n        value: meme[key]\n      };\n    })\n  };\n\n  const fetch = require('cross-fetch');\n  const ENDPOINT = `https://${process.env.REACT_APP_ASTRA_DB_ID}-${process.env.REACT_APP_ASTRA_DB_REGION}.apps.astra.datastax.com/api/rest/v1`;\n  const REACT_APP_ASTRA_DB_KEYSPACE = process.env.REACT_APP_ASTRA_DB_KEYSPACE;\n  const TABLE_NAME = 'memes_saved';\n  const {authToken} = await getOrCreateAuthToken();\n\n  try {\n    const response = await fetch(`${ENDPOINT}/keyspaces/${REACT_APP_ASTRA_DB_KEYSPACE}/tables/${TABLE_NAME}/rows`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'x-cassandra-token': authToken,\n      },\n      body: JSON.stringify(columns)\n    });\n    return JSON.stringify(await response.json());\n  } catch (e) {\n    return JSON.stringify(e);\n  }\n\n};","import React, { Component } from \"react\";\nimport \"./Generator.css\";\nimport Image from \"./Image2\";\nimport \"./ImageList.css\"\nimport * as svg from \"save-svg-as-png\";\nimport utils from './utils/utils';\nimport {saveMemes} from './utils/api';\nimport {getMemesSaved} from './utils/api';\n\nconst initialState = {\n    toptext: \"\",\n    bottomtext: \"\",\n    isTopDragging: false,\n    isBottomDragging: false,\n    topX: \"50%\",\n    topY: \"10%\",\n    bottomX: \"50%\",\n    bottomY: \"90%\",\n    saved_images: []\n};\n\nclass TempGen extends Component {\n    constructor() {\n        super();\n        this.state = {\n            ...initialState\n        };\n    }\n\n    getSessionId() {\n        // Check if a session id query parameter exists\n        const params = new URLSearchParams(window.location.search);\n        if (params.get('session-id')) {\n          return params.get('session-id');\n        }\n\n        // Check if a session id is stored to local storage\n        if (utils.store('session-id')) {\n          return utils.store('session-id');\n        }\n\n        // Otherwise, generate a new session id\n        const sid = utils.uuid();\n        utils.store('session-id', sid);\n        return sid;\n    };\n\n    getStateObj = (e, type) => {\n        let rect = this.imageRef.getBoundingClientRect();\n        const xOffset = e.clientX - rect.left;\n        const yOffset = e.clientY - rect.top;\n        let stateObj = {};\n        if (type === \"bottom\") {\n            stateObj = {\n                isBottomDragging: true,\n                isTopDragging: false,\n                bottomX: `${xOffset}px`,\n                bottomY: `${yOffset}px`,\n            };\n        } else if (type === \"top\") {\n            stateObj = {\n                isTopDragging: true,\n                isBottomDragging: false,\n                topX: `${xOffset}px`,\n                topY: `${yOffset}px`,\n            };\n        }\n        return stateObj;\n    };\n\n    changeText = (event) => {\n        this.setState({\n            [event.currentTarget.id]: event.currentTarget.value,\n        });\n        let type = event.currentTarget.name\n        this.resizeText(type)\n    };\n\n    handleMouseDown = (e, type) => {\n        const stateObj = this.getStateObj(e, type);\n        document.addEventListener(\"mousemove\", (event) =>\n            this.handleMouseMove(event, type)\n        );\n        this.setState({\n            ...stateObj,\n        });\n    };\n\n    handleMouseMove = (e, type) => {\n        if (this.state.isTopDragging || this.state.isBottomDragging) {\n            let stateObj = {};\n            if (type === \"bottom\" && this.state.isBottomDragging) {\n                stateObj = this.getStateObj(e, type);\n            } else if (type === \"top\" && this.state.isTopDragging) {\n                stateObj = this.getStateObj(e, type);\n            }\n            this.setState({\n                ...stateObj,\n            });\n        }\n    };\n\n    handleMouseUp = (event) => {\n        document.removeEventListener(\"mousemove\", this.handleMouseMove);\n        this.setState({\n            isTopDragging: false,\n            isBottomDragging: false,\n        });\n    };\n\n    saveMeme = () => {\n\n        let name = document.getElementById(\"memename\").value\n        name.length > 0 ?\n            svg.saveSvgAsPng(document.getElementById(\"svg_ref\"), `${name}.png`) :\n            svg.saveSvgAsPng(document.getElementById(\"svg_ref\"), \"meme.png\")\n        \n        svg.svgAsPngUri(document.getElementById(\"svg_ref\")).then(image_source => {\n            //console.log(image_source);\n            const sessionId = this.getSessionId();\n            const meme = this.props.meme;\n            meme['sessionid'] = sessionId;\n            meme['memename'] = document.getElementById(\"memename\").value;\n            meme['toptext'] = document.getElementById(\"toptext\").value;\n            meme['bottomtext'] = document.getElementById(\"bottomtext\").value;\n            meme['image_source'] = image_source;\n\n            saveMemes(meme,sessionId)\n              .then(data => {\n                    //console.log(data);\n                });\n\n        });\n        \n    };\n\n    resetBoxes = () => {\n        this.setState({\n            toptext: \"\",\n            bottomtext: \"\",\n            topX: \"50%\",\n            topY: \"10%\",\n            bottomX: \"50%\",\n            bottomY: \"90%\"\n        });\n        document.getElementById(\"toptext\").value = \"\";\n        document.getElementById(\"bottomtext\").value = \"\";\n        document.getElementById(\"memename\").value = \"\";\n        document.getElementById(\"tiptoptext\").style.fontSize = \"50px\"\n        document.getElementById(\"bittybottomtext\").style.fontSize = \"50px\"\n    }\n\n    resizeText = (type) => {\n        let currentWidth = document.getElementById(type).textLength.baseVal.value\n        let imageWidth = this.props.meme.width\n        if (currentWidth > imageWidth) {\n            document.getElementById(type).style.fontSize = `${(imageWidth / currentWidth) * 40}px`;\n        }\n    }\n\n    componentDidMount() {\n        const imageId = this.props.meme.id;\n        //console.log(imageId);\n        //const query = [];\n        //    query['columnNames'] = [\"image_source\"];\n        //    query['filters'] = [{\"value\":[\"161865971\"],\"columnName\":\"image_source\",\"operator\":\"eq\"}];\n        // i had some issues building the object so I just ended up using the original test string\n        const query = '{ \"columnNames\": [\"uuid\",\"id\",\"name\",\"image_source\"], \"filters\": [{\"value\": [\"' + imageId + '\"],\"columnName\": \"id\",\"operator\": \"eq\"}]}';\n        getMemesSaved(query)\n          .then(data => {\n                this.setState({ saved_images: data.rows });\n            });\n    }\n\n    render() {\n        const image = this.props.meme;\n        \n        var wrh = image.width / image.height;\n        var newWidth = 500;\n        var newHeight = newWidth / wrh;\n\n        const textStyle = {\n            fontFamily: \"Impact\",\n            fontSize: \"50px\",\n            textTransform: \"uppercase\",\n            fill: \"#FFF\",\n            stroke: \"#000\",\n            userSelect: \"none\"\n        };\n\n        return (\n            <div>\n                <div className=\"h1\" onClick={() => this.props.toggleSelected()}>\n                    MEME GENERATOR\n                </div>\n                <div className=\"main-content\">\n                    <div className=\"meme-gen-modal\">\n                        <svg\n                            id=\"svg_ref\"\n                            ref={(el) => { this.svgRef = el; }}\n                            height={newHeight}\n                            width={newWidth}\n                        >\n                            <image\n                                ref={(el) => {\n                                    this.imageRef = el;\n                                }}\n                                xlinkHref={this.props.meme.url}\n                                height={newHeight}\n                                width={newWidth}\n                            />\n\n                            <text\n                                id=\"tiptoptext\"\n                                style={{ ...textStyle, zIndex: this.state.isTopDragging ? 4 : 1 }}\n                                x={this.state.topX}\n                                y={this.state.topY}\n                                dominantBaseline=\"middle\"\n                                textAnchor=\"middle\"\n                                onMouseDown={(event) => this.handleMouseDown(event, \"top\")}\n                                onMouseUp={(event) => this.handleMouseUp(event, \"top\")}\n                            >\n                                {this.state.toptext}\n                            </text>\n\n                            <text\n                                id=\"bittybottomtext\"\n                                style={textStyle}\n                                dominantBaseline=\"middle\"\n                                textAnchor=\"middle\"\n                                x={this.state.bottomX}\n                                y={this.state.bottomY}\n                                onMouseDown={(event) => this.handleMouseDown(event, \"bottom\")}\n                                onMouseUp={(event) => this.handleMouseUp(event, \"bottom\")}\n                            >\n                                {this.state.bottomtext}\n                            </text>\n                        </svg>\n                        <div className=\"meme-form\">\n                            <input\n                                className=\"form-control\"\n                                type=\"text\"\n                                name=\"tiptoptext\"\n                                id=\"toptext\"\n                                placeholder=\"Add text to the top\"\n                                onChange={this.changeText}\n                            />\n\n                            <input\n                                className=\"form-control\"\n                                type=\"text\"\n                                name=\"bittybottomtext\"\n                                id=\"bottomtext\"\n                                placeholder=\"Add text to the bottom\"\n                                onChange={this.changeText}\n                            />\n                            <input\n                                className=\"form-control\"\n                                type=\"text\"\n                                id=\"memename\"\n                                placeholder=\"Save meme as...\"\n                            />\n                        </div>\n                        <div className=\"buttons\">\n                            <button onClick={this.saveMeme} className=\"btn btn-primary\">Download Meme :D</button>\n                            <button onClick={this.resetBoxes} className=\"btn btn-primary\">Reset</button>\n                            <button onClick={() => this.props.toggleSelected()} className=\"btn btn-primary\">Back to Gallery</button>\n                        </div>\n\n                    </div>\n                </div>\n                <div className=\"image-list\">\n                  {this.state.saved_images.map((image) => {\n                    return (\n                      <Image\n                        key={image.uuid}\n                        image={image}\n                      />\n                    );\n                  })}\n                </div>\n            </div>\n        );\n    }\n}\n\nexport default TempGen;\n","import React, { Component } from \"react\";\nimport Gallery from \"./Gallery\";\nimport TempGen from \"./TempGen\";\nimport utils from './utils/utils';\n//import {getMemes} from './utils/api';\n\nexport default class App extends Component {\n  state = {\n    images: [],\n    memes: [],\n    selected: null,\n    selectedImg: [],\n  };\n\n  handleImgClick = (e) => {\n    this.setState({\n      selectedImg: this.state.images.find(i => i.id === e.target.id),\n    });\n    this.toggleSelected()\n  };\n\n  chooseRandom = () => {\n    this.setState({ selected: true, selectedImg: this.state.images[Math.floor(Math.random() * this.state.images.length)] })\n  }\n\n  toggleComponent = () => {\n    if (this.state.selected) {\n      return <TempGen meme={this.state.selectedImg} toggleSelected={this.toggleSelected} />;\n    } else {\n      return (\n        <Gallery\n          handleRandom={this.chooseRandom}\n          images={this.state.images}\n          handleclick={this.handleImgClick}\n        />\n      );\n    }\n  };\n\n  getSessionId() {\n    // Check if a session id query parameter exists\n    const params = new URLSearchParams(window.location.search);\n    if (params.get('session-id')) {\n      return params.get('session-id');\n    }\n\n    // Check if a session id is stored to local storage\n    if (utils.store('session-id')) {\n      return utils.store('session-id');\n    }\n\n    // Otherwise, generate a new session id\n    const sid = utils.uuid();\n    utils.store('session-id', sid);\n    return sid;\n  }\n\n  render() {\n    \n    return <div>\n      {this.toggleComponent()}\n    </div>;\n  }\n\n  toggleSelected = () => {\n    this.setState({ selected: !this.state.selected })\n  }\n\n  componentDidMount() {\n    //const sessionId = this.getSessionId();\n    //getMemes(sessionId)\n    //  .then(data => {\n    //        this.setState({ images: data.rows.filter((i) => i.box_count === 2) });\n    //    });\n    fetch(\"https://api.imgflip.com/get_memes\")\n      .then((r) => r.json())\n      .then((images) => {\n        console.log(images);\n        this.setState({ images: images.data.memes.filter((i) => i.box_count === 2) });\n      });\n  }\n  \n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}